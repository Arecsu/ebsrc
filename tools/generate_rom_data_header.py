#!/usr/bin/env python3
"""
ROM Data Header Generator for EarthBound Decompilation Project

This script generates include/rom_data.h by parsing ASM symbol files to create
clean C interfaces for accessing ROM data (text, graphics, audio, etc.).

Usage: python3 tools/generate_rom_data_header.py
"""

import os
import re
import glob
from pathlib import Path

def parse_symbol_file(filepath):
    """Parse an ASM symbol file and extract .GLOBAL declarations"""
    symbols = []
    
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Match .GLOBAL symbol_name: far
                match = re.match(r'^\.GLOBAL\s+([A-Z_][A-Z0-9_]*)\s*:\s*far\s*$', line)
                if match:
                    symbol_name = match.group(1)
                    symbols.append({
                        'name': symbol_name,
                        'file': os.path.basename(filepath),
                        'line': line_num
                    })
                    
    except Exception as e:
        print(f"Warning: Could not parse {filepath}: {e}")
        
    return symbols

def categorize_symbols(symbols):
    """Categorize symbols by type for organized header generation"""
    categories = {
        'battle_messages': [],
        'event_messages': [],
        'global_messages': [],
        'audio_data': [],
        'graphics_data': [],
        'other': []
    }
    
    for symbol in symbols:
        name = symbol['name']
        
        if name.startswith('MSG_BTL_'):
            categories['battle_messages'].append(symbol)
        elif name.startswith('MSG_EVENT_') or name.startswith('MSG_E'):
            categories['event_messages'].append(symbol)  
        elif name.startswith('MSG_'):
            categories['global_messages'].append(symbol)
        elif name.startswith('AUDIOPACK_') or name.startswith('MUSIC_'):
            categories['audio_data'].append(symbol)
        elif name.startswith('SPRITE_') or name.startswith('TILESET_'):
            categories['graphics_data'].append(symbol)
        else:
            categories['other'].append(symbol)
            
    return categories

def generate_header_content(categories):
    """Generate the complete rom_data.h header content"""
    
    header = """#ifndef ROM_DATA_H
#define ROM_DATA_H

/*
 * ROM Data Access Header - Auto-generated
 * 
 * This file provides clean C interfaces to ROM data including text messages,
 * graphics, audio, and other game assets. All symbols are extracted from 
 * the original ROM and linked at build time.
 *
 * DO NOT EDIT MANUALLY - Generated by tools/generate_rom_data_header.py
 */

#ifdef __cplusplus
extern "C" {
#endif

// =============================================================================
// BATTLE SYSTEM MESSAGES
// =============================================================================

"""

    # Battle Messages
    if categories['battle_messages']:
        for symbol in sorted(categories['battle_messages'], key=lambda x: x['name']):
            header += f"extern const unsigned char* const {symbol['name']};\n"
        header += "\n"
    
    # Event Messages  
    if categories['event_messages']:
        header += "// =============================================================================\n"
        header += "// EVENT AND DIALOGUE MESSAGES\n" 
        header += "// =============================================================================\n\n"
        
        for symbol in sorted(categories['event_messages'], key=lambda x: x['name']):
            header += f"extern const unsigned char* const {symbol['name']};\n"
        header += "\n"
    
    # Global Messages
    if categories['global_messages']:
        header += "// =============================================================================\n"
        header += "// GLOBAL GAME MESSAGES\n"
        header += "// =============================================================================\n\n"
        
        for symbol in sorted(categories['global_messages'], key=lambda x: x['name']):
            header += f"extern const unsigned char* const {symbol['name']};\n" 
        header += "\n"
        
    # Audio Data
    if categories['audio_data']:
        header += "// =============================================================================\n"
        header += "// AUDIO AND MUSIC DATA\n"
        header += "// =============================================================================\n\n"
        
        for symbol in sorted(categories['audio_data'], key=lambda x: x['name']):
            header += f"extern const unsigned char {symbol['name']}[];\n"
        header += "\n"
        
    # Graphics Data
    if categories['graphics_data']:
        header += "// =============================================================================\n" 
        header += "// GRAPHICS AND SPRITE DATA\n"
        header += "// =============================================================================\n\n"
        
        for symbol in sorted(categories['graphics_data'], key=lambda x: x['name']):
            header += f"extern const unsigned char {symbol['name']}[];\n"
        header += "\n"
        
    # Other symbols
    if categories['other']:
        header += "// =============================================================================\n"
        header += "// OTHER ROM DATA\n"
        header += "// =============================================================================\n\n"
        
        for symbol in sorted(categories['other'], key=lambda x: x['name']):
            header += f"extern const unsigned char* const {symbol['name']};\n"
        header += "\n"

    # Data access functions
    header += """// =============================================================================
// ROM DATA ACCESS FUNCTIONS
// =============================================================================

// Text/Message access functions
const char* get_battle_message(const unsigned char* const message_ptr);
const char* get_event_message(const unsigned char* const message_ptr);
const char* get_global_message(const unsigned char* const message_ptr);

// Audio data access functions
const unsigned char* get_audio_pack(unsigned char pack_id);
const unsigned char* get_music_track(unsigned short track_id);

// Graphics data access functions  
const unsigned char* get_sprite_data(unsigned short sprite_id);
const unsigned char* get_tileset_data(unsigned char tileset_id);

#ifdef __cplusplus
}
#endif

#endif // ROM_DATA_H
"""
    
    return header

def main():
    """Main generator function"""
    print("Generating ROM data header...")
    
    # Find all symbol files
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    
    symbol_pattern = str(project_root / "src" / "bin" / "US" / "text_data" / "*.symbols.asm")
    symbol_files = glob.glob(symbol_pattern)
    
    if not symbol_files:
        print(f"Warning: No symbol files found in pattern: {symbol_pattern}")
        return
        
    print(f"Found {len(symbol_files)} symbol files")
    
    # Parse all symbol files
    all_symbols = []
    for symbol_file in symbol_files:
        print(f"Parsing {os.path.basename(symbol_file)}...")
        symbols = parse_symbol_file(symbol_file)
        all_symbols.extend(symbols)
        
    print(f"Extracted {len(all_symbols)} symbols total")
    
    # Categorize symbols
    categories = categorize_symbols(all_symbols)
    
    # Print statistics
    for category, symbols in categories.items():
        if symbols:
            print(f"  {category}: {len(symbols)} symbols")
    
    # Generate header content
    header_content = generate_header_content(categories)
    
    # Write header file
    output_path = project_root / "include" / "rom_data.h" 
    output_path.parent.mkdir(exist_ok=True)
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(header_content)
        
    print(f"Generated: {output_path}")
    print(f"Total symbols: {len(all_symbols)}")

if __name__ == "__main__":
    main()